["[\"# This is an example configuration file for the LVM2 system.\\n\", \"# It contains the default settings that would be used if there was no\\n\", \"# /etc/lvm/lvm.conf file.\\n\", \"#\\n\", \"# Refer to 'man lvm.conf' for further information including the file layout.\\n\", \"#\\n\", \"# To put this file in a different directory and override /etc/lvm set\\n\", \"# the environment variable LVM_SYSTEM_DIR before running the tools.\\n\", \"#\\n\", \"# N.B. Take care that each setting only appears once if uncommenting\\n\", \"# example settings in this file.\\n\", \"\\n\", \"\\n\", \"# This section allows you to configure which block devices should\\n\", \"# be used by the LVM system.\\n\", \"devices {\\n\", \"\\n\", \"    # Where do you want your volume groups to appear ?\\n\", \"    dir = \\\"/dev\\\"\\n\", \"\\n\", \"    # An array of directories that contain the device nodes you wish\\n\", \"    # to use with LVM2.\\n\", \"    scan = [ \\\"/dev\\\" ]\\n\", \"\\n\", \"    # If set, the cache of block device nodes with all associated symlinks\\n\", \"    # will be constructed out of the existing udev database content.\\n\", \"    # This avoids using and opening any inapplicable non-block devices or\\n\", \"    # subdirectories found in the device directory. This setting is applied\\n\", \"    # to udev-managed device directory only, other directories will be scanned\\n\", \"    # fully. LVM2 needs to be compiled with udev support for this setting to\\n\", \"    # take effect. N.B. Any device node or symlink not managed by udev in\\n\", \"    # udev directory will be ignored with this setting on.\\n\", \"    obtain_device_list_from_udev = 1\\n\", \"\\n\", \"    # If several entries in the scanned directories correspond to the\\n\", \"    # same block device and the tools need to display a name for device,\\n\", \"    # all the pathnames are matched against each item in the following\\n\", \"    # list of regular expressions in turn and the first match is used.\\n\", \"    # preferred_names = [ ]\\n\", \"\\n\", \"    # Try to avoid using undescriptive /dev/dm-N names, if present.\\n\", \"    preferred_names = [ \\\"^/dev/mpath/\\\", \\\"^/dev/mapper/mpath\\\", \\\"^/dev/[hs]d\\\" ]\\n\", \"\\n\", \"    # A filter that tells LVM2 to only use a restricted set of devices.\\n\", \"    # The filter consists of an array of regular expressions.  These\\n\", \"    # expressions can be delimited by a character of your choice, and\\n\", \"    # prefixed with either an 'a' (for accept) or 'r' (for reject).\\n\", \"    # The first expression found to match a device name determines if\\n\", \"    # the device will be accepted or rejected (ignored).  Devices that\\n\", \"    # don't match any patterns are accepted.\\n\", \"\\n\", \"    # Be careful if there there are symbolic links or multiple filesystem \\n\", \"    # entries for the same device as each name is checked separately against\\n\", \"    # the list of patterns.  The effect is that if the first pattern in the \\n\", \"    # list to match a name is an 'a' pattern for any of the names, the device\\n\", \"    # is accepted; otherwise if the first pattern in the list to match a name\\n\", \"    # is an 'r' pattern for any of the names it is rejected; otherwise it is\\n\", \"    # accepted.\\n\", \"\\n\", \"    # Don't have more than one filter line active at once: only one gets used.\\n\", \"\\n\", \"    # Run vgscan after you change this parameter to ensure that\\n\", \"    # the cache file gets regenerated (see below).\\n\", \"    # If it doesn't do what you expect, check the output of 'vgscan -vvvv'.\\n\", \"\\n\", \"\\n\", \"    # By default we accept every block device:\\n\", \"    filter = [ \\\"a|/dev/mapper/newtest_vg600_d001|\\\", \\\"a|/dev/mapper/newtest_vg600_d002|\\\", \\\"a|/dev/mapper/newtest_vg601_d001|\\\", \\\"a|/dev/mapper/newtest_vg601_d002|\\\", \\\"r|.*|\\\" ]\\n\", \"\\n\", \"    # Exclude the cdrom drive\\n\", \"    # filter = [ \\\"r|/dev/cdrom|\\\" ]\\n\", \"\\n\", \"    # When testing I like to work with just loopback devices:\\n\", \"    # filter = [ \\\"a/loop/\\\", \\\"r/.*/\\\" ]\\n\", \"\\n\", \"    # Or maybe all loops and ide drives except hdc:\\n\", \"    # filter =[ \\\"a|loop|\\\", \\\"r|/dev/hdc|\\\", \\\"a|/dev/ide|\\\", \\\"r|.*|\\\" ]\\n\", \"\\n\", \"    # Use anchors if you want to be really specific\\n\", \"    # filter = [ \\\"a|^/dev/hda8$|\\\", \\\"r/.*/\\\" ]\\n\", \"\\n\", \"    # Since \\\"filter\\\" is often overriden from command line, it is not suitable\\n\", \"    # for system-wide device filtering (udev rules, lvmetad). To hide devices\\n\", \"    # from LVM-specific udev processing and/or from lvmetad, you need to set\\n\", \"    # global_filter. The syntax is the same as for normal \\\"filter\\\"\\n\", \"    # above. Devices that fail the global_filter are not even opened by LVM.\\n\", \"\\n\", \"    # global_filter = []\\n\", \"\\n\", \"    # The results of the filtering are cached on disk to avoid\\n\", \"    # rescanning dud devices (which can take a very long time).\\n\", \"    # By default this cache is stored in the /etc/lvm/cache directory\\n\", \"    # in a file called '.cache'.\\n\", \"    # It is safe to delete the contents: the tools regenerate it.\\n\", \"    # (The old setting 'cache' is still respected if neither of\\n\", \"    # these new ones is present.)\\n\", \"    # N.B. If obtain_device_list_from_udev is set to 1 the list of\\n\", \"    # devices is instead obtained from udev and any existing .cache\\n\", \"    # file is removed.\\n\", \"    cache_dir = \\\"/etc/lvm/cache\\\"\\n\", \"    cache_file_prefix = \\\"\\\"\\n\", \"\\n\", \"    # You can turn off writing this cache file by setting this to 0.\\n\", \"    write_cache_state = 1\\n\", \"\\n\", \"    # Advanced settings.\\n\", \"\\n\", \"    # List of pairs of additional acceptable block device types found \\n\", \"    # in /proc/devices with maximum (non-zero) number of partitions.\\n\", \"    # types = [ \\\"fd\\\", 16 ]\\n\", \"\\n\", \"    # If sysfs is mounted (2.6 kernels) restrict device scanning to \\n\", \"    # the block devices it believes are valid.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    sysfs_scan = 1\\n\", \"\\n\", \"    # By default, LVM2 will ignore devices used as component paths\\n\", \"    # of device-mapper multipath devices.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    multipath_component_detection = 1\\n\", \"\\n\", \"    # By default, LVM2 will ignore devices used as components of\\n\", \"    # software RAID (md) devices by looking for md superblocks.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    md_component_detection = 1\\n\", \"\\n\", \"    # By default, if a PV is placed directly upon an md device, LVM2\\n\", \"    # will align its data blocks with the md device's stripe-width.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    md_chunk_alignment = 1\\n\", \"\\n\", \"    # Default alignment of the start of a data area in MB.  If set to 0,\\n\", \"    # a value of 64KB will be used.  Set to 1 for 1MiB, 2 for 2MiB, etc.\\n\", \"    # default_data_alignment = 1\\n\", \"\\n\", \"    # By default, the start of a PV's data area will be a multiple of\\n\", \"    # the 'minimum_io_size' or 'optimal_io_size' exposed in sysfs.\\n\", \"    # - minimum_io_size - the smallest request the device can perform\\n\", \"    #   w/o incurring a read-modify-write penalty (e.g. MD's chunk size)\\n\", \"    # - optimal_io_size - the device's preferred unit of receiving I/O\\n\", \"    #   (e.g. MD's stripe width)\\n\", \"    # minimum_io_size is used if optimal_io_size is undefined (0).\\n\", \"    # If md_chunk_alignment is enabled, that detects the optimal_io_size.\\n\", \"    # This setting takes precedence over md_chunk_alignment.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    data_alignment_detection = 1\\n\", \"\\n\", \"    # Alignment (in KB) of start of data area when creating a new PV.\\n\", \"    # md_chunk_alignment and data_alignment_detection are disabled if set.\\n\", \"    # Set to 0 for the default alignment (see: data_alignment_default)\\n\", \"    # or page size, if larger.\\n\", \"    data_alignment = 0\\n\", \"\\n\", \"    # By default, the start of the PV's aligned data area will be shifted by\\n\", \"    # the 'alignment_offset' exposed in sysfs.  This offset is often 0 but\\n\", \"    # may be non-zero; e.g.: certain 4KB sector drives that compensate for\\n\", \"    # windows partitioning will have an alignment_offset of 3584 bytes\\n\", \"    # (sector 7 is the lowest aligned logical block, the 4KB sectors start\\n\", \"    # at LBA -1, and consequently sector 63 is aligned on a 4KB boundary).\\n\", \"    # But note that pvcreate --dataalignmentoffset will skip this detection.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    data_alignment_offset_detection = 1\\n\", \"\\n\", \"    # If, while scanning the system for PVs, LVM2 encounters a device-mapper\\n\", \"    # device that has its I/O suspended, it waits for it to become accessible.\\n\", \"    # Set this to 1 to skip such devices.  This should only be needed\\n\", \"    # in recovery situations.\\n\", \"    ignore_suspended_devices = 0\\n\", \"\\n\", \"    # During each LVM operation errors received from each device are counted.\\n\", \"    # If the counter of a particular device exceeds the limit set here, no\\n\", \"    # further I/O is sent to that device for the remainder of the respective\\n\", \"    # operation. Setting the parameter to 0 disables the counters altogether.\\n\", \"    disable_after_error_count = 0\\n\", \"\\n\", \"    # Allow use of pvcreate --uuid without requiring --restorefile.\\n\", \"    require_restorefile_with_uuid = 1\\n\", \"\\n\", \"    # Minimum size (in KB) of block devices which can be used as PVs.\\n\", \"    # In a clustered environment all nodes must use the same value.\\n\", \"    # Any value smaller than 512KB is ignored.\\n\", \"\\n\", \"    # Ignore devices smaller than 2MB such as floppy drives.\\n\", \"    pv_min_size = 2048\\n\", \"\\n\", \"    # The original built-in setting was 512 up to and including version 2.02.84.\\n\", \"    # pv_min_size = 512\\n\", \"\\n\", \"    # Issue discards to a logical volumes's underlying physical volume(s) when\\n\", \"    # the logical volume is no longer using the physical volumes' space (e.g.\\n\", \"    # lvremove, lvreduce, etc).  Discards inform the storage that a region is\\n\", \"    # no longer in use.  Storage that supports discards advertise the protocol\\n\", \"    # specific way discards should be issued by the kernel (TRIM, UNMAP, or\\n\", \"    # WRITE SAME with UNMAP bit set).  Not all storage will support or benefit\\n\", \"    # from discards but SSDs and thinly provisioned LUNs generally do.  If set\\n\", \"    # to 1, discards will only be issued if both the storage and kernel provide\\n\", \"    # support.\\n\", \"    # 1 enables; 0 disables.\\n\", \"    issue_discards = 0\\n\", \"}\\n\", \"\\n\", \"# This section allows you to configure the way in which LVM selects\\n\", \"# free space for its Logical Volumes.\\n\", \"allocation {\\n\", \"\\n\", \"    # When searching for free space to extend an LV, the \\\"cling\\\"\\n\", \"    # allocation policy will choose space on the same PVs as the last\\n\", \"    # segment of the existing LV.  If there is insufficient space and a\\n\", \"    # list of tags is defined here, it will check whether any of them are\\n\", \"    # attached to the PVs concerned and then seek to match those PV tags\\n\", \"    # between existing extents and new extents.\\n\", \"    # Use the special tag \\\"@*\\\" as a wildcard to match any PV tag.\\n\", \" \\n\", \"    # Example: LVs are mirrored between two sites within a single VG.\\n\", \"    # PVs are tagged with either @site1 or @site2 to indicate where\\n\", \"    # they are situated.\\n\", \"\\n\", \"    # cling_tag_list = [ \\\"@site1\\\", \\\"@site2\\\" ]\\n\", \"    # cling_tag_list = [ \\\"@*\\\" ]\\n\", \"\\n\", \"    # Changes made in version 2.02.85 extended the reach of the 'cling'\\n\", \"    # policies to detect more situations where data can be grouped\\n\", \"    # onto the same disks.  Set this to 0 to revert to the previous\\n\", \"    # algorithm.\\n\", \"    maximise_cling = 1\\n\", \"\\n\", \"    # Set to 1 to guarantee that mirror logs will always be placed on \\n\", \"    # different PVs from the mirror images.  This was the default\\n\", \"    # until version 2.02.85.\\n\", \"    mirror_logs_require_separate_pvs = 0\\n\", \"\\n\", \"    # Set to 1 to guarantee that thin pool metadata will always\\n\", \"    # be placed on different PVs from the pool data.\\n\", \"    thin_pool_metadata_require_separate_pvs = 0\\n\", \"\\n\", \"    # Specify the minimal chunk size (in KB) for thin pool volumes.\\n\", \"    # Use of the larger chunk size may improve perfomance for plain\\n\", \"    # thin volumes, however using them for snapshot volumes is less efficient,\\n\", \"    # as it consumes more space and takes extra time for copying.\\n\", \"    # When unset, lvm tries to estimate chunk size starting from 64KB\\n\", \"    # Supported values are in range from 64 to 1048576.\\n\", \"    # thin_pool_chunk_size = 64\\n\", \"\\n\", \"    # Specify discards behavior of the thin pool volume.\\n\", \"    # Select one of  \\\"ignore\\\", \\\"nopassdown\\\", \\\"passdown\\\"\\n\", \"    # thin_pool_discards = \\\"passdown\\\"\\n\", \"\\n\", \"    # Set to 0, to disable zeroing of thin pool data chunks before their\\n\", \"    # first use.\\n\", \"    # N.B. zeroing larger thin pool chunk size degrades performance.\\n\", \"    # thin_pool_zero = 1\\n\", \"}\\n\", \"\\n\", \"# This section that allows you to configure the nature of the\\n\", \"# information that LVM2 reports.\\n\", \"log {\\n\", \"\\n\", \"    # Controls the messages sent to stdout or stderr.\\n\", \"    # There are three levels of verbosity, 3 being the most verbose.\\n\", \"    verbose = 0\\n\", \"\\n\", \"    # Set to 1 to suppress all non-essential messages from stdout.\\n\", \"    # This has the same effect as -qq.\\n\", \"    # When this is set, the following commands still produce output:\\n\", \"    # dumpconfig, lvdisplay, lvmdiskscan, lvs, pvck, pvdisplay, \\n\", \"    # pvs, version, vgcfgrestore -l, vgdisplay, vgs.\\n\", \"    # Non-essential messages are shifted from log level 4 to log level 5\\n\", \"    # for syslog and lvm2_log_fn purposes.\\n\", \"    # Any 'yes' or 'no' questions not overridden by other arguments\\n\", \"    # are suppressed and default to 'no'.\\n\", \"    silent = 0\\n\", \"\\n\", \"    # Should we send log messages through syslog?\\n\", \"    # 1 is yes; 0 is no.\\n\", \"    syslog = 1\\n\", \"\\n\", \"    # Should we log error and debug messages to a file?\\n\", \"    # By default there is no log file.\\n\", \"    #file = \\\"/var/log/lvm2.log\\\"\\n\", \"\\n\", \"    # Should we overwrite the log file each time the program is run?\\n\", \"    # By default we append.\\n\", \"    overwrite = 0\\n\", \"\\n\", \"    # What level of log messages should we send to the log file and/or syslog?\\n\", \"    # There are 6 syslog-like log levels currently in use - 2 to 7 inclusive.\\n\", \"    # 7 is the most verbose (LOG_DEBUG).\\n\", \"    level = 0\\n\", \"\\n\", \"    # Format of output messages\\n\", \"    # Whether or not (1 or 0) to indent messages according to their severity\\n\", \"    indent = 1\\n\", \"\\n\", \"    # Whether or not (1 or 0) to display the command name on each line output\\n\", \"    command_names = 0\\n\", \"\\n\", \"    # A prefix to use before the message text (but after the command name,\\n\", \"    # if selected).  Default is two spaces, so you can see/grep the severity\\n\", \"    # of each message.\\n\", \"    prefix = \\\"  \\\"\\n\", \"\\n\", \"    # To make the messages look similar to the original LVM tools use:\\n\", \"    #   indent = 0\\n\", \"    #   command_names = 1\\n\", \"    #   prefix = \\\" -- \\\"\\n\", \"\\n\", \"    # Set this if you want log messages during activation.\\n\", \"    # Don't use this in low memory situations (can deadlock).\\n\", \"    # activation = 0\\n\", \"}\\n\", \"\\n\", \"# Configuration of metadata backups and archiving.  In LVM2 when we\\n\", \"# talk about a 'backup' we mean making a copy of the metadata for the\\n\", \"# *current* system.  The 'archive' contains old metadata configurations.\\n\", \"# Backups are stored in a human readeable text format.\\n\", \"backup {\\n\", \"\\n\", \"    # Should we maintain a backup of the current metadata configuration ?\\n\", \"    # Use 1 for Yes; 0 for No.\\n\", \"    # Think very hard before turning this off!\\n\", \"    backup = 1\\n\", \"\\n\", \"    # Where shall we keep it ?\\n\", \"    # Remember to back up this directory regularly!\\n\", \"    backup_dir = \\\"/etc/lvm/backup\\\"\\n\", \"\\n\", \"    # Should we maintain an archive of old metadata configurations.\\n\", \"    # Use 1 for Yes; 0 for No.\\n\", \"    # On by default.  Think very hard before turning this off.\\n\", \"    archive = 1\\n\", \"\\n\", \"    # Where should archived files go ?\\n\", \"    # Remember to back up this directory regularly!\\n\", \"    archive_dir = \\\"/etc/lvm/archive\\\"\\n\", \"\\n\", \"    # What is the minimum number of archive files you wish to keep ?\\n\", \"    retain_min = 10\\n\", \"\\n\", \"    # What is the minimum time you wish to keep an archive file for ?\\n\", \"    retain_days = 30\\n\", \"}\\n\", \"\\n\", \"# Settings for the running LVM2 in shell (readline) mode.\\n\", \"shell {\\n\", \"\\n\", \"    # Number of lines of history to store in ~/.lvm_history\\n\", \"    history_size = 100\\n\", \"}\\n\", \"\\n\", \"\\n\", \"# Miscellaneous global LVM2 settings\\n\", \"global {\\n\", \"\\n\", \"    # The file creation mask for any files and directories created.\\n\", \"    # Interpreted as octal if the first digit is zero.\\n\", \"    umask = 077\\n\", \"\\n\", \"    # Allow other users to read the files\\n\", \"    #umask = 022\\n\", \"\\n\", \"    # Enabling test mode means that no changes to the on disk metadata\\n\", \"    # will be made.  Equivalent to having the -t option on every\\n\", \"    # command.  Defaults to off.\\n\", \"    test = 0\\n\", \"\\n\", \"    # Default value for --units argument\\n\", \"    units = \\\"h\\\"\\n\", \"\\n\", \"    # Since version 2.02.54, the tools distinguish between powers of\\n\", \"    # 1024 bytes (e.g. KiB, MiB, GiB) and powers of 1000 bytes (e.g.\\n\", \"    # KB, MB, GB).\\n\", \"    # If you have scripts that depend on the old behaviour, set this to 0\\n\", \"    # temporarily until you update them.\\n\", \"    si_unit_consistency = 1\\n\", \"\\n\", \"    # Whether or not to communicate with the kernel device-mapper.\\n\", \"    # Set to 0 if you want to use the tools to manipulate LVM metadata \\n\", \"    # without activating any logical volumes.\\n\", \"    # If the device-mapper kernel driver is not present in your kernel\\n\", \"    # setting this to 0 should suppress the error messages.\\n\", \"    activation = 1\\n\", \"\\n\", \"    # If we can't communicate with device-mapper, should we try running \\n\", \"    # the LVM1 tools?\\n\", \"    # This option only applies to 2.4 kernels and is provided to help you\\n\", \"    # switch between device-mapper kernels and LVM1 kernels.\\n\", \"    # The LVM1 tools need to be installed with .lvm1 suffices\\n\", \"    # e.g. vgscan.lvm1 and they will stop working after you start using\\n\", \"    # the new lvm2 on-disk metadata format.\\n\", \"    # The default value is set when the tools are built.\\n\", \"    # fallback_to_lvm1 = 0\\n\", \"\\n\", \"    # The default metadata format that commands should use - \\\"lvm1\\\" or \\\"lvm2\\\".\\n\", \"    # The command line override is -M1 or -M2.\\n\", \"    # Defaults to \\\"lvm2\\\".\\n\", \"    # format = \\\"lvm2\\\"\\n\", \"\\n\", \"    # Location of proc filesystem\\n\", \"    proc = \\\"/proc\\\"\\n\", \"\\n\", \"    # Type of locking to use. Defaults to local file-based locking (1).\\n\", \"    # Turn locking off by setting to 0 (dangerous: risks metadata corruption\\n\", \"    # if LVM2 commands get run concurrently).\\n\", \"    # Type 2 uses the external shared library locking_library.\\n\", \"    # Type 3 uses built-in clustered locking.\\n\", \"    # Type 4 uses read-only locking which forbids any operations that might \\n\", \"    # change metadata.\\n\", \"    locking_type = 1\\n\", \"\\n\", \"    # Set to 0 to fail when a lock request cannot be satisfied immediately.\\n\", \"    wait_for_locks = 1\\n\", \"\\n\", \"    # If using external locking (type 2) and initialisation fails,\\n\", \"    # with this set to 1 an attempt will be made to use the built-in\\n\", \"    # clustered locking.\\n\", \"    # If you are using a customised locking_library you should set this to 0.\\n\", \"    fallback_to_clustered_locking = 1\\n\", \"\\n\", \"    # If an attempt to initialise type 2 or type 3 locking failed, perhaps\\n\", \"    # because cluster components such as clvmd are not running, with this set\\n\", \"    # to 1 an attempt will be made to use local file-based locking (type 1).\\n\", \"    # If this succeeds, only commands against local volume groups will proceed.\\n\", \"    # Volume Groups marked as clustered will be ignored.\\n\", \"    fallback_to_local_locking = 1\\n\", \"\\n\", \"    # Local non-LV directory that holds file-based locks while commands are\\n\", \"    # in progress.  A directory like /tmp that may get wiped on reboot is OK.\\n\", \"    locking_dir = \\\"/var/lock/lvm\\\"\\n\", \"\\n\", \"    # Whenever there are competing read-only and read-write access requests for\\n\", \"    # a volume group's metadata, instead of always granting the read-only\\n\", \"    # requests immediately, delay them to allow the read-write requests to be\\n\", \"    # serviced.  Without this setting, write access may be stalled by a high\\n\", \"    # volume of read-only requests.\\n\", \"    # NB. This option only affects locking_type = 1 viz. local file-based\\n\", \"    # locking.\\n\", \"    prioritise_write_locks = 1\\n\", \"\\n\", \"    # Other entries can go here to allow you to load shared libraries\\n\", \"    # e.g. if support for LVM1 metadata was compiled as a shared library use\\n\", \"    #   format_libraries = \\\"liblvm2format1.so\\\" \\n\", \"    # Full pathnames can be given.\\n\", \"\\n\", \"    # Search this directory first for shared libraries.\\n\", \"    #   library_dir = \\\"/lib\\\"\\n\", \"\\n\", \"    # The external locking library to load if locking_type is set to 2.\\n\", \"    #   locking_library = \\\"liblvm2clusterlock.so\\\"\\n\", \"\\n\", \"    # Treat any internal errors as fatal errors, aborting the process that\\n\", \"    # encountered the internal error. Please only enable for debugging.\\n\", \"    abort_on_internal_errors = 0\\n\", \"\\n\", \"    # Check whether CRC is matching when parsed VG is used multiple times.\\n\", \"    # This is useful to catch unexpected internal cached volume group\\n\", \"    # structure modification. Please only enable for debugging.\\n\", \"    detect_internal_vg_cache_corruption = 0\\n\", \"\\n\", \"    # If set to 1, no operations that change on-disk metadata will be permitted.\\n\", \"    # Additionally, read-only commands that encounter metadata in need of repair\\n\", \"    # will still be allowed to proceed exactly as if the repair had been \\n\", \"    # performed (except for the unchanged vg_seqno).\\n\", \"    # Inappropriate use could mess up your system, so seek advice first!\\n\", \"    metadata_read_only = 0\\n\", \"\\n\", \"    # 'mirror_segtype_default' defines which segtype will be used when the\\n\", \"    # shorthand '-m' option is used for mirroring.  The possible options are:\\n\", \"    #\\n\", \"    # \\\"mirror\\\" - The original RAID1 implementation provided by LVM2/DM.  It is\\n\", \"    # \\t         characterized by a flexible log solution (core, disk, mirrored)\\n\", \"    #\\t\\t and by the necessity to block I/O while reconfiguring in the\\n\", \"    #\\t\\t event of a failure.\\n\", \"    #\\n\", \"    #\\t\\t There is an inherent race in the dmeventd failure handling\\n\", \"    #\\t\\t logic with snapshots of devices using this type of RAID1 that\\n\", \"    #\\t\\t in the worst case could cause a deadlock.\\n\", \"    #\\t\\t   Ref: https://bugzilla.redhat.com/show_bug.cgi?id=817130#c10\\n\", \"    #\\n\", \"    # \\\"raid1\\\"  - This implementation leverages MD's RAID1 personality through\\n\", \"    # \\t       \\t device-mapper.  It is characterized by a lack of log options.\\n\", \"    #\\t\\t (A log is always allocated for every device and they are placed\\n\", \"    #\\t\\t on the same device as the image - no separate devices are\\n\", \"    #\\t\\t required.)  This mirror implementation does not require I/O\\n\", \"    #\\t\\t to be blocked in the kernel in the event of a failure.\\n\", \"    #\\t\\t This mirror implementation is not cluster-aware and cannot be\\n\", \"    #\\t\\t used in a shared (active/active) fashion in a cluster.\\n\", \"    #\\n\", \"    # Specify the '--type <mirror|raid1>' option to override this default\\n\", \"    # setting.\\n\", \"    mirror_segtype_default = \\\"mirror\\\"\\n\", \"\\n\", \"    # The default format for displaying LV names in lvdisplay was changed \\n\", \"    # in version 2.02.89 to show the LV name and path separately.\\n\", \"    # Previously this was always shown as /dev/vgname/lvname even when that\\n\", \"    # was never a valid path in the /dev filesystem.\\n\", \"    # Set to 1 to reinstate the previous format.\\n\", \"    #\\n\", \"    # lvdisplay_shows_full_device_path = 0\\n\", \"\\n\", \"    # Whether to use (trust) a running instance of lvmetad. If this is set to\\n\", \"    # 0, all commands fall back to the usual scanning mechanisms. When set to 1\\n\", \"    # *and* when lvmetad is running (it is not auto-started), the volume group\\n\", \"    # metadata and PV state flags are obtained from the lvmetad instance and no\\n\", \"    # scanning is done by the individual commands. In a setup with lvmetad,\\n\", \"    # lvmetad udev rules *must* be set up for LVM to work correctly. Without\\n\", \"    # proper udev rules, all changes in block device configuration will be\\n\", \"    # *ignored* until a manual 'pvscan --cache' is performed.\\n\", \"    #\\n\", \"    # If lvmetad has been running while use_lvmetad was 0, it MUST be stopped\\n\", \"    # before changing use_lvmetad to 1 and started again afterwards.\\n\", \"    use_lvmetad = 0\\n\", \"\\n\", \"    # Full path of the utility called to check that a thin metadata device\\n\", \"    # is in a state that allows it to be used.\\n\", \"    # Each time a thin pool needs to be activated or after it is deactivated\\n\", \"    # this utility is executed. The activation will only proceed if the utility\\n\", \"    # has an exit status of 0.\\n\", \"    # Set to \\\"\\\" to skip this check.  (Not recommended.)\\n\", \"    # The thin tools are available as part of the device-mapper-persistent-data\\n\", \"    # package from https://github.com/jthornber/thin-provisioning-tools.\\n\", \"    #\\n\", \"    thin_check_executable = \\\"/usr/sbin/thin_check\\\"\\n\", \"\\n\", \"    # String with options passed with thin_check command. By default,\\n\", \"    # option '-q' is for quiet output.\\n\", \"    thin_check_options = [ \\\"-q\\\" ]\\n\", \"\\n\", \"    # If set, given features are not used by thin driver.\\n\", \"    # This can be helpful not just for testing, but i.e. allows to avoid\\n\", \"    # using problematic implementation of some thin feature.\\n\", \"    # Features:\\n\", \"    #   block_size\\n\", \"    #   discards\\n\", \"    #   discards_non_power_2\\n\", \"    #\\n\", \"    # thin_disabled_features = [ \\\"discards\\\", \\\"block_size\\\" ]\\n\", \"}\\n\", \"\\n\", \"activation {\\n\", \"    # Set to 1 to perform internal checks on the operations issued to\\n\", \"    # libdevmapper.  Useful for debugging problems with activation.\\n\", \"    # Some of the checks may be expensive, so it's best to use this\\n\", \"    # only when there seems to be a problem.\\n\", \"    checks = 0\\n\", \"\\n\", \"    # Set to 0 to disable udev synchronisation (if compiled into the binaries).\\n\", \"    # Processes will not wait for notification from udev.\\n\", \"    # They will continue irrespective of any possible udev processing\\n\", \"    # in the background.  You should only use this if udev is not running\\n\", \"    # or has rules that ignore the devices LVM2 creates.\\n\", \"    # The command line argument --nodevsync takes precedence over this setting.\\n\", \"    # If set to 1 when udev is not running, and there are LVM2 processes\\n\", \"    # waiting for udev, run 'dmsetup udevcomplete_all' manually to wake them up.\\n\", \"    udev_sync = 1\\n\", \"\\n\", \"    # Set to 0 to disable the udev rules installed by LVM2 (if built with\\n\", \"    # --enable-udev_rules). LVM2 will then manage the /dev nodes and symlinks\\n\", \"    # for active logical volumes directly itself.\\n\", \"    # N.B. Manual intervention may be required if this setting is changed\\n\", \"    # while any logical volumes are active.\\n\", \"    udev_rules = 1\\n\", \"\\n\", \"    # Set to 1 for LVM2 to verify operations performed by udev. This turns on\\n\", \"    # additional checks (and if necessary, repairs) on entries in the device\\n\", \"    # directory after udev has completed processing its events. \\n\", \"    # Useful for diagnosing problems with LVM2/udev interactions.\\n\", \"    verify_udev_operations = 0\\n\", \"\\n\", \"    # If set to 1 and if deactivation of an LV fails, perhaps because\\n\", \"    # a process run from a quick udev rule temporarily opened the device,\\n\", \"    # retry the operation for a few seconds before failing.\\n\", \"    retry_deactivation = 1\\n\", \"\\n\", \"    # How to fill in missing stripes if activating an incomplete volume.\\n\", \"    # Using \\\"error\\\" will make inaccessible parts of the device return\\n\", \"    # I/O errors on access.  You can instead use a device path, in which \\n\", \"    # case, that device will be used to in place of missing stripes.\\n\", \"    # But note that using anything other than \\\"error\\\" with mirrored \\n\", \"    # or snapshotted volumes is likely to result in data corruption.\\n\", \"    missing_stripe_filler = \\\"error\\\"\\n\", \"\\n\", \"    # The linear target is an optimised version of the striped target\\n\", \"    # that only handles a single stripe.  Set this to 0 to disable this\\n\", \"    # optimisation and always use the striped target.\\n\", \"    use_linear_target = 1\\n\", \"\\n\", \"    # How much stack (in KB) to reserve for use while devices suspended\\n\", \"    # Prior to version 2.02.89 this used to be set to 256KB\\n\", \"    reserved_stack = 64\\n\", \"\\n\", \"    # How much memory (in KB) to reserve for use while devices suspended\\n\", \"    reserved_memory = 8192\\n\", \"\\n\", \"    # Nice value used while devices suspended\\n\", \"    process_priority = -18\\n\", \"\\n\", \"    # If volume_list is defined, each LV is only activated if there is a\\n\", \"    # match against the list.\\n\", \"    #   \\\"vgname\\\" and \\\"vgname/lvname\\\" are matched exactly.\\n\", \"    #   \\\"@tag\\\" matches any tag set in the LV or VG.\\n\", \"    #   \\\"@*\\\" matches if any tag defined on the host is also set in the LV or VG\\n\", \"    #\\n\", \"    # volume_list = [ \\\"vg1\\\", \\\"vg2/lvol1\\\", \\\"@tag1\\\", \\\"@*\\\" ]\\n\", \"\\n\", \"    # If auto_activation_volume_list is defined, each LV that is to be\\n\", \"    # activated is checked against the list while using the autoactivation\\n\", \"    # option (--activate ay/-a ay), and if it matches, it is activated.\\n\", \"    #   \\\"vgname\\\" and \\\"vgname/lvname\\\" are matched exactly.\\n\", \"    #   \\\"@tag\\\" matches any tag set in the LV or VG.\\n\", \"    #   \\\"@*\\\" matches if any tag defined on the host is also set in the LV or VG\\n\", \"    #\\n\", \"    # auto_activation_volume_list = [ \\\"vg1\\\", \\\"vg2/lvol1\\\", \\\"@tag1\\\", \\\"@*\\\" ]\\n\", \"\\n\", \"    # If read_only_volume_list is defined, each LV that is to be activated \\n\", \"    # is checked against the list, and if it matches, it as activated\\n\", \"    # in read-only mode.  (This overrides '--permission rw' stored in the\\n\", \"    # metadata.)\\n\", \"    #   \\\"vgname\\\" and \\\"vgname/lvname\\\" are matched exactly.\\n\", \"    #   \\\"@tag\\\" matches any tag set in the LV or VG.\\n\", \"    #   \\\"@*\\\" matches if any tag defined on the host is also set in the LV or VG\\n\", \"    #\\n\", \"    # read_only_volume_list = [ \\\"vg1\\\", \\\"vg2/lvol1\\\", \\\"@tag1\\\", \\\"@*\\\" ]\\n\", \"\\n\", \"    # Size (in KB) of each copy operation when mirroring\\n\", \"    mirror_region_size = 512\\n\", \"\\n\", \"    # Setting to use when there is no readahead value stored in the metadata.\\n\", \"    #\\n\", \"    # \\\"none\\\" - Disable readahead.\\n\", \"    # \\\"auto\\\" - Use default value chosen by kernel.\\n\", \"    readahead = \\\"auto\\\"\\n\", \"\\n\", \"    # 'raid_fault_policy' defines how a device failure in a RAID logical\\n\", \"    # volume is handled.  This includes logical volumes that have the following\\n\", \"    # segment types: raid1, raid4, raid5*, and raid6*.\\n\", \"    #\\n\", \"    # In the event of a failure, the following policies will determine what\\n\", \"    # actions are performed during the automated response to failures (when\\n\", \"    # dmeventd is monitoring the RAID logical volume) and when 'lvconvert' is\\n\", \"    # called manually with the options '--repair' and '--use-policies'.\\n\", \"    #\\n\", \"    # \\\"warn\\\"\\t- Use the system log to warn the user that a device in the RAID\\n\", \"    # \\t\\t  logical volume has failed.  It is left to the user to run\\n\", \"    #\\t\\t  'lvconvert --repair' manually to remove or replace the failed\\n\", \"    #\\t\\t  device.  As long as the number of failed devices does not\\n\", \"    #\\t\\t  exceed the redundancy of the logical volume (1 device for\\n\", \"    #\\t\\t  raid4/5, 2 for raid6, etc) the logical volume will remain\\n\", \"    #\\t\\t  usable.\\n\", \"    #\\n\", \"    # \\\"allocate\\\" - Attempt to use any extra physical volumes in the volume\\n\", \"    # \\t\\t  group as spares and replace faulty devices.\\n\", \"    #\\n\", \"    raid_fault_policy = \\\"warn\\\"\\n\", \"\\n\", \"    # 'mirror_image_fault_policy' and 'mirror_log_fault_policy' define\\n\", \"    # how a device failure affecting a mirror (of \\\"mirror\\\" segment type) is\\n\", \"    # handled.  A mirror is composed of mirror images (copies) and a log.\\n\", \"    # A disk log ensures that a mirror does not need to be re-synced\\n\", \"    # (all copies made the same) every time a machine reboots or crashes.\\n\", \"    #\\n\", \"    # In the event of a failure, the specified policy will be used to determine\\n\", \"    # what happens. This applies to automatic repairs (when the mirror is being\\n\", \"    # monitored by dmeventd) and to manual lvconvert --repair when\\n\", \"    # --use-policies is given.\\n\", \"    #\\n\", \"    # \\\"remove\\\" - Simply remove the faulty device and run without it.  If\\n\", \"    #            the log device fails, the mirror would convert to using\\n\", \"    #            an in-memory log.  This means the mirror will not\\n\", \"    #            remember its sync status across crashes/reboots and\\n\", \"    #            the entire mirror will be re-synced.  If a\\n\", \"    #            mirror image fails, the mirror will convert to a\\n\", \"    #            non-mirrored device if there is only one remaining good\\n\", \"    #            copy.\\n\", \"    #\\n\", \"    # \\\"allocate\\\" - Remove the faulty device and try to allocate space on\\n\", \"    #            a new device to be a replacement for the failed device.\\n\", \"    #            Using this policy for the log is fast and maintains the\\n\", \"    #            ability to remember sync state through crashes/reboots.\\n\", \"    #            Using this policy for a mirror device is slow, as it\\n\", \"    #            requires the mirror to resynchronize the devices, but it\\n\", \"    #            will preserve the mirror characteristic of the device.\\n\", \"    #            This policy acts like \\\"remove\\\" if no suitable device and\\n\", \"    #            space can be allocated for the replacement.\\n\", \"    #\\n\", \"    # \\\"allocate_anywhere\\\" - Not yet implemented. Useful to place the log device\\n\", \"    #            temporarily on same physical volume as one of the mirror\\n\", \"    #            images. This policy is not recommended for mirror devices\\n\", \"    #            since it would break the redundant nature of the mirror. This\\n\", \"    #            policy acts like \\\"remove\\\" if no suitable device and space can\\n\", \"    #            be allocated for the replacement.\\n\", \"\\n\", \"    mirror_log_fault_policy = \\\"allocate\\\"\\n\", \"    mirror_image_fault_policy = \\\"remove\\\"\\n\", \"\\n\", \"    # 'snapshot_autoextend_threshold' and 'snapshot_autoextend_percent' define\\n\", \"    # how to handle automatic snapshot extension. The former defines when the\\n\", \"    # snapshot should be extended: when its space usage exceeds this many\\n\", \"    # percent. The latter defines how much extra space should be allocated for\\n\", \"    # the snapshot, in percent of its current size.\\n\", \"    #\\n\", \"    # For example, if you set snapshot_autoextend_threshold to 70 and\\n\", \"    # snapshot_autoextend_percent to 20, whenever a snapshot exceeds 70% usage,\\n\", \"    # it will be extended by another 20%. For a 1G snapshot, using up 700M will\\n\", \"    # trigger a resize to 1.2G. When the usage exceeds 840M, the snapshot will\\n\", \"    # be extended to 1.44G, and so on.\\n\", \"    #\\n\", \"    # Setting snapshot_autoextend_threshold to 100 disables automatic\\n\", \"    # extensions. The minimum value is 50 (A setting below 50 will be treated\\n\", \"    # as 50).\\n\", \"\\n\", \"    snapshot_autoextend_threshold = 100\\n\", \"    snapshot_autoextend_percent = 20\\n\", \"\\n\", \"    # 'thin_pool_autoextend_threshold' and 'thin_pool_autoextend_percent' define\\n\", \"    # how to handle automatic pool extension. The former defines when the\\n\", \"    # pool should be extended: when its space usage exceeds this many\\n\", \"    # percent. The latter defines how much extra space should be allocated for\\n\", \"    # the pool, in percent of its current size.\\n\", \"    #\\n\", \"    # For example, if you set thin_pool_autoextend_threshold to 70 and\\n\", \"    # thin_pool_autoextend_percent to 20, whenever a pool exceeds 70% usage,\\n\", \"    # it will be extended by another 20%. For a 1G pool, using up 700M will\\n\", \"    # trigger a resize to 1.2G. When the usage exceeds 840M, the pool will\\n\", \"    # be extended to 1.44G, and so on.\\n\", \"    #\\n\", \"    # Setting thin_pool_autoextend_threshold to 100 disables automatic\\n\", \"    # extensions. The minimum value is 50 (A setting below 50 will be treated\\n\", \"    # as 50).\\n\", \"\\n\", \"    thin_pool_autoextend_threshold = 100\\n\", \"    thin_pool_autoextend_percent = 20\\n\", \"\\n\", \"    # While activating devices, I/O to devices being (re)configured is\\n\", \"    # suspended, and as a precaution against deadlocks, LVM2 needs to pin\\n\", \"    # any memory it is using so it is not paged out.  Groups of pages that\\n\", \"    # are known not to be accessed during activation need not be pinned\\n\", \"    # into memory.  Each string listed in this setting is compared against\\n\", \"    # each line in /proc/self/maps, and the pages corresponding to any\\n\", \"    # lines that match are not pinned.  On some systems locale-archive was\\n\", \"    # found to make up over 80% of the memory used by the process.\\n\", \"    # mlock_filter = [ \\\"locale/locale-archive\\\", \\\"gconv/gconv-modules.cache\\\" ]\\n\", \"\\n\", \"    # Set to 1 to revert to the default behaviour prior to version 2.02.62\\n\", \"    # which used mlockall() to pin the whole process's memory while activating\\n\", \"    # devices.\\n\", \"    use_mlockall = 0\\n\", \"\\n\", \"    # Monitoring is enabled by default when activating logical volumes.\\n\", \"    # Set to 0 to disable monitoring or use the --ignoremonitoring option.\\n\", \"    monitoring = 1\\n\", \"\\n\", \"    # When pvmove or lvconvert must wait for the kernel to finish\\n\", \"    # synchronising or merging data, they check and report progress\\n\", \"    # at intervals of this number of seconds.  The default is 15 seconds.\\n\", \"    # If this is set to 0 and there is only one thing to wait for, there\\n\", \"    # are no progress reports, but the process is awoken immediately the\\n\", \"    # operation is complete.\\n\", \"    polling_interval = 15\\n\", \"}\\n\", \"\\n\", \"\\n\", \"####################\\n\", \"# Advanced section #\\n\", \"####################\\n\", \"\\n\", \"# Metadata settings\\n\", \"#\\n\", \"# metadata {\\n\", \"    # Default number of copies of metadata to hold on each PV.  0, 1 or 2.\\n\", \"    # You might want to override it from the command line with 0 \\n\", \"    # when running pvcreate on new PVs which are to be added to large VGs.\\n\", \"\\n\", \"    # pvmetadatacopies = 1\\n\", \"\\n\", \"    # Default number of copies of metadata to maintain for each VG.\\n\", \"    # If set to a non-zero value, LVM automatically chooses which of\\n\", \"    # the available metadata areas to use to achieve the requested\\n\", \"    # number of copies of the VG metadata.  If you set a value larger\\n\", \"    # than the the total number of metadata areas available then\\n\", \"    # metadata is stored in them all.\\n\", \"    # The default value of 0 (\\\"unmanaged\\\") disables this automatic\\n\", \"    # management and allows you to control which metadata areas\\n\", \"    # are used at the individual PV level using 'pvchange\\n\", \"    # --metadataignore y/n'.\\n\", \"\\n\", \"    # vgmetadatacopies = 0\\n\", \"\\n\", \"    # Approximate default size of on-disk metadata areas in sectors.\\n\", \"    # You should increase this if you have large volume groups or\\n\", \"    # you want to retain a large on-disk history of your metadata changes.\\n\", \"\\n\", \"    # pvmetadatasize = 255\\n\", \"\\n\", \"    # List of directories holding live copies of text format metadata.\\n\", \"    # These directories must not be on logical volumes!\\n\", \"    # It's possible to use LVM2 with a couple of directories here,\\n\", \"    # preferably on different (non-LV) filesystems, and with no other \\n\", \"    # on-disk metadata (pvmetadatacopies = 0). Or this can be in\\n\", \"    # addition to on-disk metadata areas.\\n\", \"    # The feature was originally added to simplify testing and is not\\n\", \"    # supported under low memory situations - the machine could lock up.\\n\", \"    #\\n\", \"    # Never edit any files in these directories by hand unless you\\n\", \"    # you are absolutely sure you know what you are doing! Use\\n\", \"    # the supplied toolset to make changes (e.g. vgcfgrestore).\\n\", \"\\n\", \"    # dirs = [ \\\"/etc/lvm/metadata\\\", \\\"/mnt/disk2/lvm/metadata2\\\" ]\\n\", \"#}\\n\", \"\\n\", \"# Event daemon\\n\", \"#\\n\", \"dmeventd {\\n\", \"    # mirror_library is the library used when monitoring a mirror device.\\n\", \"    #\\n\", \"    # \\\"libdevmapper-event-lvm2mirror.so\\\" attempts to recover from\\n\", \"    # failures.  It removes failed devices from a volume group and\\n\", \"    # reconfigures a mirror as necessary. If no mirror library is\\n\", \"    # provided, mirrors are not monitored through dmeventd.\\n\", \"\\n\", \"    mirror_library = \\\"libdevmapper-event-lvm2mirror.so\\\"\\n\", \"\\n\", \"    # snapshot_library is the library used when monitoring a snapshot device.\\n\", \"    #\\n\", \"    # \\\"libdevmapper-event-lvm2snapshot.so\\\" monitors the filling of\\n\", \"    # snapshots and emits a warning through syslog when the use of\\n\", \"    # the snapshot exceeds 80%. The warning is repeated when 85%, 90% and\\n\", \"    # 95% of the snapshot is filled.\\n\", \"\\n\", \"    snapshot_library = \\\"libdevmapper-event-lvm2snapshot.so\\\"\\n\", \"\\n\", \"    # thin_library is the library used when monitoring a thin device.\\n\", \"    #\\n\", \"    # \\\"libdevmapper-event-lvm2thin.so\\\" monitors the filling of\\n\", \"    # pool and emits a warning through syslog when the use of\\n\", \"    # the pool exceeds 80%. The warning is repeated when 85%, 90% and\\n\", \"    # 95% of the pool is filled.\\n\", \"\\n\", \"    thin_library = \\\"libdevmapper-event-lvm2thin.so\\\"\\n\", \"\\n\", \"    # Full path of the dmeventd binary.\\n\", \"    #\\n\", \"    # executable = \\\"/sbin/dmeventd\\\"\\n\", \"}\\n\"]"]